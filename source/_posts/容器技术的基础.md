---
title: 容器技术的基础
catalog: true
date: 2023-08-09 21:00:00
subtitle: 
tags:
    - 容器
categories:
    - 技术
index_img: https://liarsa-me.oss-cn-beijing.aliyuncs.com/img/logo/docker-bg1.jpg
# banner_img: /img/bg/wallhaven-vqdmxm.png
---

# 容器技术的基础

## 1. 从进程开始说起

假如现在要写一个计算加法的小程序，这个程序需要的输入来自一个文件，计算完成后的结果则输出到另一个文件中。  

由于计算机只认识 0 和 1，因此无论这段代码是用哪种语言编写的，最后都需要通过某种方式翻译二进制文件，才能在计算机操作系统中运行。

为了能够让这些代码正常运行，我们往往要给它提供数据，比如在这个加法程序中所需要的输入文件。这些数据加上代码本身的二进制文件放在磁盘上，就是我们平常所说的一个“<b>程序</b>“。

首先，操作系统从“程序”中发现输入数据保存在一个文件中，然后这些数据会被加载到内存中待命。同时，操作系统又读取到了计算加法的指令，这时，它就需要知识 CPU 完成加法操作。而 CPU 与内存协作进行加法计算，又会使用寄存器存放数值，内存堆栈保存执行的命令和变量。同时，计算机里还有被打开的文件，以及各种各样的 I/O 设备在不断的调用中修改自己的状态。

就这样，“程序”一旦被执行，它就从磁盘上的二进制文件变成了由计算机内存中的数据、寄存器里的值、堆栈中的指令、被打开的文件，以及各种设备的状态信息组成的一个集合。像这样一个程序运行起来之后的计算机执行环境的总和，就是“<b>进程</b>”

<b>容器技术的核心：就是通过约束和修改进程的动态表现，为其创造一个“边界”</b>

对于 Linux 容器来说：

 - Cgroups 技术是用来制造约束的主要手段。
 - Namespace 技术是用来修改进程视图的主要方法。 


现在让我们创建一个容器：

```sh
$ docker run -it busybox /bin/sh
/ #
```

接下来，执行 ps 命令

```sh
/# ps
PID   USER    TIME  COMMAND
  1   root    0:00   /bin/sh
 10   root    0:00   ps
```

可以看到，在 Docker 里最开始执行的 /bin/sh 就是这个容器内部的第 1 号进程（PID=1），而容器里共有两个进程在运行。

这种对被隔离应用的进程空间动了手脚，使得这些进程只能“看到”重新计算过的 PID，比如 PID=1，可实际上，在宿主机的操作系统里，还是原来的 100 号进程。这种技术就是 Linux 的 Namespace 机制。

Linux 系统中创建线程的系统调用是 clone()，比如：

```c
int pid = clone(main_function, stack_size, CLONE_NEWPID | SIGCHLD, NULL);
```

这时，创建的进程就会”看到“一个全新的进程空间。在这个进程空间里，它的 PID 是 1.

Linux 命名空间种类：

 - PID
 - Mount
 - UTS
 - IPC
 - Network
 - User

 可见，<font style="color: #008080;font-weight: bold;">容器其实是一种特殊的进程而已。</font>

![虚拟机和容器的对比图](/img/article/kubernetes/vm_docker_description.png)

<b>总结：Docker 项目帮助用户启动的还是原来的应用进程，只不过在创建这些进程时，Docker 为它们加上了各种各样的 Namespace 参数。</b>


## 2. 隔离与限制

Linux Namespace 实际上修改了应用进程看待整个计算机“视图”的视野。

虚拟机优势和劣势：

 - 隔离得彻底。
 - 自身占用资源。
 - 系统调用等导致的性能损耗。

虚拟机优势和劣势
 
 - 高性能、低损耗。
 - 隔离得不彻底，共享内核。
 - 很多资源和对象不能被 Namespace 化，最典型的例子就是：时间。

Linux Cgroups 是 Linux 内核中用来为进程设置资源限制的一个重要功能。

 - 限制一个进程组能够使用的资源上限，包括 CPU、内存、磁盘、网络宽带等。
 - 对进程进行优先级设置、审计，以及进程挂起和恢复等操作。

Cgroups 无法限制 /proc 文件系统，导致容器内 top 看到的数据和宿主机的数据相同。

## 3. 深入理解容器镜像

挂载在容器根目录上用来为容器进程提供隔离后执行环境的文件系统，就是所谓的“容器镜像“（rootfs，根文件系统）

Docker 项目最核心的原理实际上就是为待创建的用户进程：

 - 1. 启用 Linux Namespace 配置；
 - 2. 设置指定的 Cgroups 参数；
 - 3. 切换进程的根目录（change root）。

Docker 在镜像的设计中引入了层（layer）的概念，用户制作镜像的每一步操作都会生成一个层，也就是一个增量 rootfs。使用了一种叫做 UnionFS（union file system，联合文件系统）的能力。它最主要的功能是将不同位置的目录联合挂载（union mount）到同一个目录下。

https://www.cnblogs.com/arnoldlu/p/13055501.html

<hr/>
<b>参考：</b>
<ul>
    <li>[1] 张磊.深入剖析 Kubernetes[M].北京:人民邮电出版社，2021.3:17</li>
    <li>[2] <a href="https://developer.aliyun.com/article/745468" style="font-weight: bold;">[Kubernetes必备知识： Pod网络模型]</a></li>
    <li>[3] <a href="https://www.cnblogs.com/bincoding/p/16465804.html" style="font-weight: bold;">[Cgroup V2 实现cpu/mem/v2级别隔离]</a></li>
</ul>